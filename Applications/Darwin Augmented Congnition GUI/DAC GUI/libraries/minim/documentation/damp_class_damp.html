<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Minim : : Damp</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body> 
<center>
<table class="mainTable">
  <tr>
    <td class="header">
    	<span class="indexheader">Minim</span><br/>
    	<span class="indexnavigation">
    		<a href="index.html">core</a> | 
    		<a href="index_ugens.html">ugens</a> | 
    		<a href="index_analysis.html">analysis</a>
    	</span>
    </td>
    <td class="border-left">&nbsp;</td>
  </tr>
  
  <tr>
    <td class="classNavigation">
    	<p class="mainTextName">Damp</p>
    	
       <p class="linkListHeader">Fields</p>
       <p class="linkList">
           
    <a href="damp_field_audio.html" title="The default input is "audio." You don't need to patch directly to this input,
  patching to the UGen itself will accomplish the same thing.">audio</a><br/>
    
	   </p>
   
    	
       <p class="linkListHeader">Methods</p>
       <p class="linkList">
           
    <a href="damp_method_activate.html" title="Specifies that the damp envelope should begin.">activate ( )</a><br/>
    
    <a href="damp_method_channelcount.html" title="Returns the number of channels this UGen has been configured to generate.">channelCount ( )</a><br/>
    
    <a href="damp_method_getlastvalues.html" title="Return the last values generated by this UGen. This will most often be
 used by sub-classes when pulling data from their inputs.">getLastValues ( )</a><br/>
    
    <a href="damp_method_patch.html" title="Send the output of this UGen to another UGen, UGenInput, or AudioOutput.">patch ( )</a><br/>
    
    <a href="damp_method_printinputs.html" title="Prints all inputs connected to this UGen (for debugging)">printInputs ( )</a><br/>
    
    <a href="damp_method_samplerate.html" title="Returns the sample rate of this UGen.">sampleRate ( )</a><br/>
    
    <a href="damp_method_setattacktime.html" title="Permits the setting of the attackTime parameter.">setAttackTime ( )</a><br/>
    
    <a href="damp_method_setchannelcount.html" title="Let this UGen know how many channels of audio you will be asking it for.">setChannelCount ( )</a><br/>
    
    <a href="damp_method_setdamptime.html" title="Permits the setting of the attackTime parameter.">setDampTime ( )</a><br/>
    
    <a href="damp_method_setdamptimefromduration.html" title="Set the attack time and damp time parameters based on a duration.">setDampTimeFromDuration ( )</a><br/>
    
    <a href="damp_method_setsamplerate.html" title="Set the sample rate for this UGen.">setSampleRate ( )</a><br/>
    
    <a href="damp_method_tick.html" title="Generates one sample frame for this UGen.">tick ( )</a><br/>
    
    <a href="damp_method_unpatch.html" title="Unpatch this UGen from an AudioOutput or other UGen.">unpatch ( )</a><br/>
    
    <a href="damp_method_unpatchafterdamp.html" title="Tell this Damp that it should unpatch itself from the output after the release time.">unpatchAfterDamp ( )</a><br/>
    
	   </p>
   
    </td>
    <td class="mainText border-left">
    	A UGen that generates a simple envelope that changes from a starting value to a
 middle value during an "attack" phase and then changes to an ending value 
 during a "damp" or "decay" phase. By default, if you only specify a damp time,
 it will change from 1 to 0 over that period of time. Specifying only attack and 
 damp time, it will ramp up from 0 to 1 over the attack time and then 1 to 0 over 
 the damp time. All times are specified in seconds.
    	<p class="memberSectionHeader">Constructors</p>
    	<pre><em>Constructor for Damp envelope.
 attackTime, rise time of the damp envelope, defaults to 0.
 dampTime, decay time of the damp envelope, defaults to 1.
 maxAmp, maximum amlitude of the damp envelope, defaults to 1.
 befAmp, amplitude before the damp envelope,
 and aftAmp, amplitude after the damp envelope,
 default to 0.</em>
Damp()
<em>Constructor for Damp envelope.
 attackTime, rise time of the damp envelope, defaults to 0.
 maxAmp, maximum amlitude of the damp envelope, defaults to 1.
 befAmp, amplitude before the damp envelope,
 and aftAmp, amplitude after the damp envelope,
 default to 0.</em>
Damp(float dampTime)
<em>Constructor for Damp envelope.
 maxAmp, maximum amlitude of the damp envelope, defaults to 1.
 befAmp, amplitude before the damp envelope,
 and aftAmp, amplitude after the damp envelope,
 default to 0.</em>
Damp(float attackTime, float dampTime)
<em>Constructor for Damp envelope.
 befAmp, amplitude before the damp envelope,
 and aftAmp, amplitude after the damp envelope,
 default to 0.</em>
Damp(float attackTime, float dampTime, float maxAmp)
<em>Constructor for Damp envelope.</em>
Damp(float attackTime, float dampTime, float maxAmp, float befAmp, float aftAmp)
</pre>
    	
   <p class="memberSectionHeader">Parameters</p>
   
        <span class="parameterName">dampTime</span>&nbsp;&mdash;&nbsp;<span class="parameterDescription">float: decay time of the damp envelope, in seconds</span><br/>
    
        <span class="parameterName">attackTime</span>&nbsp;&mdash;&nbsp;<span class="parameterDescription">float: rise time of the damp envelope, in seconds</span><br/>
    
        <span class="parameterName">maxAmp</span>&nbsp;&mdash;&nbsp;<span class="parameterDescription">float: maximum amplitude of the damp envelope</span><br/>
    
        <span class="parameterName">befAmp</span>&nbsp;&mdash;&nbsp;<span class="parameterDescription">float: amplitude before the damp envelope</span><br/>
    
        <span class="parameterName">aftAmp</span>&nbsp;&mdash;&nbsp;<span class="parameterDescription">float: amplitude after the damp envelope</span><br/>
    
   
    	<p class="memberSectionHeader">Related</p>
    	<A href="ugen_class_ugen.html">UGen</A><BR>

    	<p class="memberSectionHeader">Example</p>
    	<pre>/* dampExample&lt;br/>
   is an example of using the Damp UGen inside an instrument.
   &lt;p>
   For more information about Minim and additional features, 
   visit http://code.compartmental.net/minim/
   &lt;p>
   author: Anderson Mills&lt;br/>
   Anderson Mills's work was supported by numediart (www.numediart.org)
*/

// import everything necessary to make sound.
import ddf.minim.*;
import ddf.minim.ugens.*;

// create all of the variables that will need to be accessed in
// more than one methods (setup(), draw(), stop()).
Minim minim;
AudioOutput out;

// Every instrument must implement the Instrument interface so 
// playNote() can call the instrument's methods.
class ToneInstrument implements Instrument
{
  // create all variables that must be used throughout the class
  Oscil sineOsc;
  Damp  damp;
  AudioOutput out;

  // constructors for this instrument  
  ToneInstrument(float frequency, float amplitude, AudioOutput output)
  {
    // equate class variables to constructor variables as necessary
    out = output;
    
    // create new instances of the UGen objects for this instrument
    sineOsc = new Oscil( frequency, amplitude, Waves.TRIANGLE );
    damp = new Damp( 0.001, 1.0 );
    
    // patch everything together up to the final output
    sineOsc.patch( damp );
  }
  
  // every instrument must have a noteOn( float ) method
  void noteOn(float dur)
  {
    // set the damp time from the duration given to the note
    damp.setDampTimeFromDuration( dur );
    // activate the damp
    damp.activate();
    // and finally patch the damp to the output
    damp.patch( out );
  }
  
  // every instrument must have a noteOff() method
  void noteOff()
  {
    // the damp time of a damp can be changed after damp has been started,
    // so unpatching after the entire damp is over is useful.
    damp.unpatchAfterDamp( out );
  }
}

// setup is run once at the beginning
void setup()
{
  // initialize the drawing window
  size( 512, 200, P2D );
  
  // initialize the minim and out objects
  minim = new Minim( this );
  out = minim.getLineOut( Minim.MONO, 2048 );
  
  // pause time when adding a bunch of notes at once
  out.pauseNotes();
  
  // one can add an offset to all notes until the next noteOffset
  out.setNoteOffset( 2f );

  // one can set the tempo of the piece in beats per minute, too
  out.setTempo( 130f );

  for( int i = 0; i &lt; 4; i++ )
  {
    // low notes
    out.playNote( 0.00 + i*4.0, 1.0, new ToneInstrument( 80, 0.5, out ) );
    out.playNote( 1.75 + i*4.0, 0.2, new ToneInstrument( 80, 0.4, out ) );
    // two extra low notes every other pattern
    if (( 0 == i ) || ( 2 == i ) )
    {
      out.playNote( 2.50 + i*4.0, 0.5, new ToneInstrument( 79, 0.3, out ) );
      out.playNote( 3.50 + i*4.0, 0.2, new ToneInstrument( 81, 0.4, out ) );
    }
    // middle notes
    out.playNote( 1.00 + i*4.0, 0.4, new ToneInstrument( 161, 0.3, out ) );
    out.playNote( 3.00 + i*4.0, 0.4, new ToneInstrument( 158, 0.3, out ) );
    
    // high notes
    out.playNote( 0.00 + i*4.0, 0.2, new ToneInstrument( 1610, 0.03, out ) );
    out.playNote( 0.50 + i*4.0, 0.2, new ToneInstrument( 2010, 0.03, out ) );
    out.playNote( 0.75 + i*4.0, 0.3, new ToneInstrument( 1650, 0.09, out ) );
    out.playNote( 1.00 + i*4.0, 0.6, new ToneInstrument( 1610, 0.09, out ) );
    out.playNote( 1.25 + i*4.0, 0.1, new ToneInstrument( 2010, 0.03, out ) );
    out.playNote( 1.50 + i*4.0, 0.5, new ToneInstrument( 1610, 0.06, out ) );

    // two extra high notes every other pattern
    if (( 1 == i ) || ( 3 == i ) )
    {
      out.playNote( 3.50 + i*4.0, 0.1, new ToneInstrument( 3210, 0.06, out ) );
      out.playNote( 3.75 + i*4.0, 0.5, new ToneInstrument( 2010, 0.09, out ) );
    }  
    
  }
  // resume time after a bunch of notes are added at once
  out.resumeNotes();
}

// draw is run many times
void draw()
{
  // erase the window to black
  background( 0 );
  // draw using a white stroke
  stroke( 255 );
  // draw the waveforms
  for( int i = 0; i &lt; out.bufferSize() - 1; i++ )
  {
    // find the x position of each buffer value
    float x1  =  map( i, 0, out.bufferSize(), 0, width );
    float x2  =  map( i+1, 0, out.bufferSize(), 0, width );
    // draw a line from one buffer position to the next for both channels
    line( x1, 50 + out.left.get(i)*50, x2, 50 + out.left.get(i+1)*50);
    line( x1, 150 + out.right.get(i)*50, x2, 150 + out.right.get(i+1)*50);
  }  
}
</pre>
    	<p class="memberSectionHeader">Usage</p>
    	Web & Application
    </td>
  </tr>
</table>
</center>
</body>
</html>